#+TITLE: perf

~perf~ provides some ideas, code and a library for low-level performance measurement for Haskell hacking. The library focuses on using the rdtsc instruction set that comes with the x86 chip to measure performance as number of cycles.

* Usage


#+begin_src haskell
#+end_src

* setup

Running this readme.org is very slow compared with an external process which accesses the compiled version of the library.

#+begin_src haskell :results output
:set prompt " > "
:set -Wno-type-defaults
:set -Wno-name-shadowing
:set -XOverloadedStrings
#+end_src

#+RESULTS:

#+begin_src haskell :results output
import Perf
import NumHask.Space (quantile)
import Data.FormatN
import Perf.Cycle
import Prelude as P
import Data.Foldable
import qualified Data.Text as Text
import qualified Data.Text.IO as Text
#+end_src

#+RESULTS:

* tick

The fundamental operation of Perf.Cycle is tick, which sandwiches a (strict) function application between two readings of the rdstc chip.

#+begin_src haskell
:t tick
#+end_src

#+RESULTS:
: tick :: (a -> b) -> a -> IO (Cycle, b)

tick returns in the IO monad, because reading a cycle counter is an IO effect. The trivial but fundamental point is that performance measurement effects the computation being measured.

Unlike benchmarking-style libraries, such as criterion, the result of the computation is passed through along with the cycle count. In this way, the `Perf` monad can be inserted into the midst of a computation in an attempt to measure performance in-situ as opposed to sitting off in a separate and perhaps unrepresentative process.

* tick_

tick_ measures the number of cycles between two clock reads.

#+begin_src haskell
:t tick_
#+end_src

#+RESULTS:
: tick_ :: IO Cycle

#+begin_src haskell
replicateM 10 tick_
#+end_src

#+RESULTS:
| 992 | 612 | 564 | 524 | 532 | 524 | 520 | 530 | 530 | 516 |

* function application

#+begin_src haskell
fmap (fmap fst) . replicateM 10 $ tick (const ()) ()
#+end_src

#+RESULTS:
| 6800 | 2646 | 2366 | 2252 | 2222 | 2322 | 2220 | 2376 | 2240 | 2190 |

Here, ~const () ()~ was evaluated and took 6.7k cycles for the first effect, reducing down to 2.2k after 10 effects. What it did in that time we will never know, really, at least from usage of ~perf~. 2.2k cycles is, on my 2.5GHz machine equal to 2200 / 2.5e9 = 8.8e-7 of a second or 880 nanoseconds.

Alternatively, ~tickIO~ measures the evaluation of an IO value.

#+begin_src haskell
:t tickIO
#+end_src

#+RESULTS:
: tickIO :: IO a -> IO (Cycle, a)

#+begin_src haskell
fmap (fmap fst) . replicateM 10 $ tickIO (pure ())
#+end_src

#+RESULTS:
| 6014 | 2396 | 1802 | 1556 | 1636 | 1550 | 1752 | 1570 | 1514 | 1542 |

#+begin_src haskell
ticks 100 (const ()) ()
#+end_src

#+RESULTS:
| 5784 | 2858 | 2416 | 2386 | 2378 | 2336 | 2336 | 2364 | 2282 | 2384 | 2316 | 2380 | 2274 | 2436 | 2328 | 2222 | 2266 | 2338 | 2320 | 2354 | 2264 | 2288 | 2366 | 2334 | 2336 | 2604 | 2398 | 2384 | 2424 | 2306 | 2374 | 2222 | 2318 | 2324 | 2242 | 2394 | 2478 | 2384 | 2306 | 2272 | 2304 | 2278 | 2248 | 2304 | 2400 | 2322 | 2278 | 2312 | 2398 | 2308 | 2356 | 2328 | 2348 | 2392 | 2374 | 2632 | 2284 | 2328 | 2294 | 2362 | 2366 | 2360 | 2356 | 2294 | 2334 | 2470 | 2422 | 2292 | 2324 | 2424 | 2406 | 2358 | 2354 | 2370 | 2396 | 2348 | 2300 | 2306 | 2428 | 2314 | 2386 | 2286 | 2424 | 2292 | 2338 | 2404 | 2390 | 2318 | 2388 | 2378 | 2304 | 2372 | 2606 | 2450 | 2396 | 2354 | 2282 | 2286 | 2378 | 2346 |

* sum example

#+begin_src haskell
fmap (comma (Just 3) . fromIntegral) . fst <$> ticks 10 sum ([1..10000] :: [Double])
#+end_src

#+RESULTS:
| 8.39e6 | 4.03e6 | 3.31e6 | 1.29e7 | 1.76e6 | 3.03e6 | 5.23e6 | 1.07e6 | 1.13e6 | 2.73e6 |


#+begin_src haskell
ts <- ticks 10000 sum ([1..1000] :: [Double])
putStrLn $ Text.unpack $ average (fst ts)
#+end_src

#+RESULTS:
: 35,300

#+begin_src haskell
:set -XAllowAmbiguousTypes

fMono :: Int -> Int
fMono x = foldl' (+) 0 [1 .. x]

fPoly :: (Enum b, Num b, Additive b) => b -> b
fPoly x = foldl' (+) 0 [1 .. x]

fLambda :: Int -> Int
fLambda = \x -> foldl' (+) 0 [1 .. x]
#+end_src

#+begin_src haskell
fmap (median . fst) (ticks 1000 fMono 1000)
#+end_src

#+RESULTS:
: )’
: "69,200"

#+begin_src haskell
fmap (median . fst) $ ticks 1000 fPoly 1000
#+end_src

#+RESULTS:
: )’
: "65,400"

#+begin_src haskell
fmap (median . fst) $ ticks 1000 fLambda 1000
#+end_src

#+RESULTS:
: )’
: "64,300"

* compiled performance

#+begin_src sh
perf-bench -r 1000 -s 1000 --median
#+end_src

#+RESULTS:
| list    | test |
| fMono   | 1954 |
| fPoly   | 1954 |
| fLambda | 1956 |

#+begin_src sh
perf-bench -r 100000 -s 1000 --median
#+end_src

#+RESULTS:
| simple  | perf | tests |
| fMono   | 1954 |       |
| fPoly   | 1954 |       |
| fLambda | 1954 |       |

* from bench.hs

FIXME: this doesn't work ...

#+begin_src haskell
:load app/bench.hs
#+end_src

#+begin_src sh
:main -r 100000 -s 1000 --median
#+end_src

#+RESULTS:

* vectors

#+begin_src sh
perf-bench -r 1000 -s 10000 --vector --median
#+end_src

#+RESULTS:
| vector    |  test |
| vBoxed    | 13291 |
| vUnboxed  | 13261 |
| vStorable | 13264 |


#+begin_src haskell
import Perf
import Perf.Cycle
import Prelude as P
import Data.Foldable
#+end_src


#+begin_src haskell
replicateM 100 tick_
#+end_src

#+RESULTS:
| 4568 | 1194 | 882 | 790 | 794 | 790 | 784 | 788 | 786 | 800 | 820 | 808 | 780 | 788 | 794 | 796 | 784 | 832 | 788 | 792 | 788 | 786 | 790 | 786 | 788 | 802 | 1038 | 822 | 796 | 796 | 792 | 786 | 792 | 782 | 798 | 792 | 788 | 790 | 788 | 848 | 792 | 794 | 784 | 800 | 792 | 802 | 794 | 790 | 786 | 788 | 794 | 788 | 782 | 794 | 788 | 792 | 782 | 794 | 792 | 792 | 788 | 786 | 792 | 792 | 788 | 784 | 782 | 790 | 790 | 786 | 790 | 794 | 782 | 794 | 790 | 786 | 788 | 780 | 788 | 786 | 794 | 786 | 786 | 894 | 796 | 790 | 786 | 782 | 786 | 788 | 794 | 790 | 772 | 788 | 800 | 790 | 790 | 790 | 792 | 832 |

* Resources

[[https://github.com/haskell-perf][Haskell performance · GitHub]]
[[https://github.com/haskell-perf/checklist][GitHub - haskell-perf/checklist: The Haskell performance checklist]]
[[https://hackage.haskell.org/package/tasty-bench-0.3/docs/Test-Tasty-Bench.html][spineless, tagless, g-machine]]
[[https://en.wikipedia.org/wiki/Time_Stamp_Counter][rdtsc]]

* space

https://github.com/ndmitchell/spaceleak
