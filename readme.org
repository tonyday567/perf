#+TITLE: perf

~perf~ provides some ideas, code and a library for low-level performance measurement for Haskell hacking. The library focuses on using the rdtsc instruction set that comes with the x86 chip to measure performance as number of cycles.

* Usage


#+begin_src haskell
import Perf
#+end_src

* setup

Running this readme.org is very slow compared with an external process which accesses the compiled version of the library.

#+begin_src haskell :results output
:set prompt " > "
:set -Wno-type-defaults
:set -Wno-name-shadowing
:set -XOverloadedStrings
#+end_src

#+RESULTS:

#+begin_src haskell :results output
import Perf
import Perf.Stats
import NumHask.Space (quantile)
import Data.FormatN
import Perf.Tick
import Prelude as P
import Data.Foldable
import qualified Data.Text as Text
import qualified Data.Text.IO as Text
#+end_src

#+RESULTS:

* tick

The fundamental operation of Perf.Tick is tick, which sandwiches a (strict) function application between two readings of the rdstc chip.

#+begin_src haskell
:t tick
#+end_src

#+RESULTS:
: tick :: (a -> b) -> a -> IO (Word64, b)

tick returns in the IO monad, because reading a cycle counter is an IO effect. The trivial but fundamental point is that performance measurement effects the computation being measured.

Unlike benchmarking-style libraries, such as criterion, the result of the computation is passed through along with the cycle count. In this way, the `Perf` monad can be inserted into the midst of a computation in an attempt to measure performance in-situ as opposed to sitting off in a separate and perhaps unrepresentative process.

* tick_

tick_ measures the number of cycles between two clock reads.

#+begin_src haskell
:t tick_
#+end_src

#+RESULTS:
: tick_ :: IO Word64

#+begin_src haskell
replicateM 10 tick_
#+end_src

#+RESULTS:
| 8530 | 910 | 730 | 668 | 642 | 648 | 644 | 642 | 646 | 640 |

* function application

#+begin_src haskell
fmap (fmap fst) . replicateM 10 $ tick (const ()) ()
#+end_src

#+RESULTS:
| 8610 | 3654 | 2900 | 2932 | 2672 | 2708 | 2684 | 2664 | 2582 | 2652 |

Here, ~const () ()~ was evaluated and took 6.7k cycles for the first effect, reducing down to 2.2k after 10 effects. What it did in that time we will never know, really, at least from usage of ~perf~. 2.2k cycles is, on my 2.5GHz machine equal to 2200 / 2.5e9 = 8.8e-7 of a second or 880 nanoseconds.

Alternatively, ~tickIO~ measures the evaluation of an IO value.

#+begin_src haskell
:t tickIO
#+end_src

#+RESULTS:
: tickIO :: IO a -> IO (Word64, a)

#+begin_src haskell
fmap (fmap fst) . replicateM 10 $ tickIO (pure ())
#+end_src

#+RESULTS:
| 5840 | 2602 | 1910 | 1698 | 1668 | 1660 | 1672 | 1676 | 1680 | 1662 |

#+begin_src haskell
ticks 100 (const ()) ()
#+end_src

#+RESULTS:
| 8226 | 3298 | 3254 | 2686 | 2694 | 2724 | 2868 | 2732 | 2644 | 2678 | 2680 | 2896 | 2734 | 2606 | 2608 | 2598 | 2606 | 2738 | 2742 | 2610 | 2554 | 2532 | 2576 | 2592 | 2600 | 2562 | 2786 | 2592 | 2646 | 2624 | 2666 | 2640 | 2640 | 2602 | 2672 | 2560 | 3478 | 2556 | 2552 | 2572 | 2622 | 2492 | 2572 | 2706 | 2544 | 2604 | 2748 | 2570 | 2596 | 3078 | 2666 | 2592 | 2612 | 2648 | 2594 | 2564 | 2716 | 2564 | 2594 | 2596 | 2554 | 2766 | 2552 | 3026 | 2602 | 2860 | 2632 | 2614 | 2620 | 2586 | 3014 | 2626 | 2626 | 2614 | 2830 | 2624 | 2616 | 2648 | 2610 | 2626 | 2610 | 2590 | 2930 | 2622 | 2732 | 2698 | 3004 | 2664 | 2948 | 2630 | 2588 | 2766 | 2726 | 2600 | 2634 | 2792 | 2704 | 2774 | 2638 | 2634 |

* sum example

#+begin_src haskell
fmap (comma (Just 3) . fromIntegral) . fst <$> ticks 10 sum ([1..10000] :: [Double])
#+end_src

#+RESULTS:
| 3,680,000 | 5,020,000 | 726,000 | 693,000 | 2,880,000 | 746,000 | 671,000 | 1,730,000 | 626,000 | 618,000 |


#+begin_src haskell
ts <- ticks 10000 sum ([1..1000] :: [Double])
putStrLn $ Text.unpack $ average (fst ts)
#+end_src

#+RESULTS:
: 58,800

#+begin_src haskell
:set -XAllowAmbiguousTypes

fMono :: Int -> Int
fMono x = foldl' (+) 0 [1 .. x]

fPoly :: (Enum b, Num b, Additive b) => b -> b
fPoly x = foldl' (+) 0 [1 .. x]

fLambda :: Int -> Int
fLambda = \x -> foldl' (+) 0 [1 .. x]
#+end_src

#+begin_src haskell
fmap (median . fst) (ticks 1000 fMono 1000)
#+end_src

#+RESULTS:
: 63,400

#+begin_src haskell
fmap (median . fst) $ ticks 1000 fPoly 1000
#+end_src

#+RESULTS:
: 63,000

#+begin_src haskell
fmap (median . fst) $ ticks 1000 fLambda 1000
#+end_src

#+RESULTS:
: 63,400

* perf results
:PROPERTIES:
:EXPORT_FILE_NAME: perf-results
:export_date: 2022-2-13
:END:

** example1

- [ ] laziness kicks in on second run of ~fap "" f a~
- [ ] cycles' best multi run

#+begin_src sh :results output
perf-example1 -r 10000 --average -l 1000
#+end_src

#+RESULTS:
: example1
: sum of one to 7132 is: 25436278
: (25436278,fromList [("",Sum {getSum = 273196}),("file read",Sum {getSum = 375068}),("length",Sum {getSum = 18702}),("print result",Sum {getSum = 27104})])
: raw results
: fromList [("PerfT cycle'",18.0),("PerfT cycles'",5925.9436),("PerfT mtick",27764.0),("PerfT mtick 0",16.0),("PerfT mtick 1",14.0),("PerfT mtick 2",16.0),("PerfT mtick 3",16.0),("PerfT mtick 4",18.0),("PerfT mticks",7282.1758),("raw multi tick",8568.6478),("raw ticks",8803.8314)]
: regressions:
: ["PerfT mtick","PerfT mticks","raw multi tick","raw ticks"]


** baseline callibration

#+begin_src sh :results output
perf-basic --help
#+end_src

#+RESULTS:
#+begin_example
basic perf callibration

Usage: perf-basic (-r|--runs ARG) (-l|--length ARG)
                  [--best | --median | --average | --averagesecs]

  perf benchmarking

Available options:
  -r,--runs ARG            number of runs to perform
  -l,--length ARG          length of list
  --best                   report upper decile
  --median                 report median
  --average                report average
  --averagesecs            report average in seconds
  -h,--help                Show this help text
#+end_example

perf-basic issues:

- [ ] ~ticks~ runs are sometimes double ~multi tick~.
- [ ] ~tickLazy~ computation escapes
- [ ] ~tick~, ~tickWHNF~, ~tickForce~, ~tickForceArgs~ same for sums
- [ ] ~tickForce~ blows out for mapInc:

  multi tickForce mapInc | 202,000, multi tickForceArgs mapInc | 57.8
- [ ] fuseSum 2000 | recSum, polySum, lambdaSum: 5750



#+begin_src sh :results drawer :exports both
perf-basic -r 10000 --average -l 1000
#+end_src

#+RESULTS:
:results:
| average fams  |                             17.5 |
| average faps  |                             80.8 |
| best fams     |                             15.5 |
| best faps     |                             15.7 |
| first 10 fams | [148,36,16,16,16,18,18,16,16,18] |
| first 10 faps | [200,14,16,18,18,18,16,20,16,16] |
| first fam     |                              148 |
| first fap     |                              200 |
| median fams   |                             17.4 |
| median faps   |                             17.8 |
:end:


#+begin_src sh :results output
ghc app/basic.hs -O2
./app/basic -r 10000 --average -l 1000
#+end_src

** noops

#+begin_src haskell
:r
:set prompt "> "
:set -XOverloadedLabels
import qualified Data.Text as Text
import qualified Data.Map.Strict as Map
import Chart
import Prelude
import Optics.Core
m <- read <$> readFile "other/noop.map" :: IO (Map.Map Text.Text [Int])
let (Just d) = Map.lookup "fap cycles'" m
filter (> 100) d
#+end_src

#+RESULTS:
| 4788 | 220 | 304 | 142 | 112 | 102 | 124 | 882950 |


#+begin_src haskell :file other/noop.svg :results output graphics file :exports results
writeChartSvg "other/noop.svg" $ mempty & #hudOptions .~ colourHudOptions (rgb light) defaultHudOptions & #charts .~ unnamed [(RectChart (defaultRectStyle & #borderSize .~ 0 & #color .~ Colour 1 1 1 1) (zipWith (\y x -> Rect x (x+1) 0 y) (fromIntegral <$> filter (<= 100) d) [0..]))]
#+end_src

#+RESULTS:
[[file:other/noop.svg]]

** tick infrastructure

#+begin_src sh
perf-basic -r 1000 -l 1000 --best --ticktypes
#+end_src

#+RESULTS:
|   |               |   count | countForce | countForceArgs | countLazy | countWHNF |  cycles |
|   | cataSum       | 11700.0 |    11700.0 |        11700.0 |      17.2 |   11700.0 | 11600.0 |
|   | foldrSum      |  9240.0 |     9260.0 |         9280.0 |      17.1 |    9270.0 |  9270.0 |
|   | fuseFoldl'Sum |  1350.0 |     1350.0 |         1350.0 |      16.1 |    1350.0 |  1350.0 |
|   | fuseFoldrSum  |  3890.0 |     3890.0 |         3890.0 |      14.9 |    3890.0 |  3890.0 |
|   | fuseSum       |  1350.0 |     1340.0 |         1350.0 |      15.3 |    1350.0 |  1350.0 |
|   | lambdaSum     | 11000.0 |    11000.0 |        11000.0 |      14.8 |   11000.0 | 11000.0 |
|   | monoSum       |  8160.0 |     8160.0 |         8150.0 |      16.6 |    8170.0 |  8150.0 |
|   | polySum       | 11000.0 |    11000.0 |        11000.0 |      16.8 |   11000.0 |  5990.0 |
|   | recSum        | 10900.0 |     5720.0 |         5720.0 |      16.7 |    5720.0 |  5690.0 |
|   | tailSum       | 11700.0 |    13500.0 |        13500.0 |      16.9 |   11700.0 | 14300.0 |
|   | tailSumGo     | 14900.0 |    13900.0 |        13900.0 |      17.1 |   14700.0 | 14700.0 |

#+begin_src sh
perf-basic -r 10000 -l 1000 --best --ticktypes
#+end_src

#+RESULTS:
|   |               |   count | countForce | countForceArgs | countLazy | countWHNF |  cycles |
|   | cataSum       |  7050.0 |     7060.0 |         7070.0 |      16.8 |    7080.0 | 17000.0 |
|   | foldrSum      |  9270.0 |     9270.0 |         9270.0 |      15.4 |    9300.0 |  9260.0 |
|   | fuseFoldl'Sum |  1350.0 |     1350.0 |         1340.0 |      15.3 |    1350.0 |  1350.0 |
|   | fuseFoldrSum  |  3890.0 |     3890.0 |         3890.0 |      16.1 |    3900.0 |  3890.0 |
|   | fuseSum       |  1350.0 |     1350.0 |         1350.0 |      15.3 |    1350.0 |  1350.0 |
|   | lambdaSum     |  5570.0 |     5560.0 |         5560.0 |      15.2 |    5560.0 |  5560.0 |
|   | monoSum       | 11000.0 |     5550.0 |         5550.0 |      15.3 |    5550.0 |  5550.0 |
|   | polySum       | 11000.0 |     5560.0 |         5510.0 |      16.8 |    5510.0 |  5520.0 |
|   | recSum        |  5720.0 |     5700.0 |         5700.0 |      17.0 |    5720.0 |  5700.0 |
|   | tailSum       |  6980.0 |     7000.0 |         7000.0 |      16.5 |    7000.0 |  6990.0 |
|   | tailSumGo     |  9270.0 |    18600.0 |        18500.0 |      15.7 |   20800.0 | 20700.0 |


*** short list
#+begin_src sh
perf-basic -r 10000 -l 10 --best --ticktypes
#+end_src

#+RESULTS:
|   |               | count | countForce | countForceArgs | countLazy | countWHNF | cycles |
|   | cataSum       | 104.0 |       90.4 |           93.4 |      15.5 |      93.0 |   91.1 |
|   | foldrSum      |  99.6 |      100.0 |          100.0 |      16.0 |     101.0 |   98.8 |
|   | fuseFoldl'Sum |  28.8 |       31.1 |           30.9 |      15.6 |      31.5 |   27.9 |
|   | fuseFoldrSum  |  53.7 |       56.0 |           56.3 |      15.1 |      55.8 |   53.5 |
|   | fuseSum       |  33.5 |       31.3 |           30.6 |      15.6 |      31.2 |   28.3 |
|   | lambdaSum     |  78.1 |       63.6 |           63.6 |      15.0 |      65.3 |   64.2 |
|   | monoSum       |  63.1 |       63.6 |           63.6 |      16.0 |      65.3 |   63.3 |
|   | polySum       |  80.1 |       77.2 |           77.2 |      15.3 |      80.8 |   77.7 |
|   | recSum        |  89.9 |       77.1 |           76.4 |      15.7 |      77.2 |   75.0 |
|   | tailSum       | 104.0 |       90.0 |           90.1 |      15.2 |      91.7 |   91.2 |
|   | tailSumGo     |  99.2 |      101.0 |          101.0 |      16.0 |     101.0 |   99.3 |

*** long list
#+begin_src sh
perf-basic -r 100 -l 100000 --best --ticktypes
#+end_src

#+RESULTS:
|   |               |     count | countForce | countForceArgs | countLazy | countWHNF |    cycles |
|   | cataSum       | 2360000.0 |  4320000.0 |      2260000.0 |      15.9 | 4680000.0 | 2300000.0 |
|   | foldrSum      | 2760000.0 |  2760000.0 |      2770000.0 |      16.6 | 2790000.0 | 2760000.0 |
|   | fuseFoldl'Sum |  139000.0 |   128000.0 |       128000.0 |      16.2 |  128000.0 |  132000.0 |
|   | fuseFoldrSum  | 1650000.0 |  1640000.0 |      1660000.0 |      16.1 | 1640000.0 | 1670000.0 |
|   | fuseSum       |  128000.0 |   128000.0 |       132000.0 |      15.5 |  132000.0 |  128000.0 |
|   | lambdaSum     | 1280000.0 |  1260000.0 |      1260000.0 |      15.8 | 1270000.0 | 1260000.0 |
|   | monoSum       |  828000.0 |   723000.0 |       720000.0 |      15.0 |  826000.0 |  722000.0 |
|   | polySum       |  731000.0 |   728000.0 |       728000.0 |      15.8 |  731000.0 |  724000.0 |
|   | recSum        | 1400000.0 |  1370000.0 |      1360000.0 |      15.2 | 1380000.0 | 1370000.0 |
|   | tailSum       | 2430000.0 |  2320000.0 |      2300000.0 |      15.9 | 2420000.0 | 2260000.0 |
|   | tailSumGo     | 3150000.0 |  2770000.0 |      2790000.0 |      16.9 | 2750000.0 | 2750000.0 |

* guage

#+begin_src sh
perf-basic -r 10000 -l 1000 --average --guage
#+end_src

#+RESULTS:
| fuseSum       |          |     |                 |      |       |    |
| benchmarking  | function | ... | function | time | 600.3 | ns |
|               |          |     |                 |      |       |    |
| benchmarking  | function | ... | function | time | 594.7 | ns |
|               |          |     |                 |      |       |    |
| fuseFoldl'Sum |          |     |                 |      |       |    |
| benchmarking  | function | ... | function | time | 601.0 | ns |
|               |          |     |                 |      |       |    |
| benchmarking  | function | ... | function | time | 595.6 | ns |
|               |          |     |                 |      |       |    |
| fuseFoldrSum  |          |     |                 |      |       |    |
| benchmarking  | function | ... | function | time | 1.731 | μs |
|               |          |     |                 |      |       |    |
| benchmarking  | function | ... | function | time | 1.699 | μs |
|               |          |     |                 |      |       |    |
| tailSum       |          |     |                 |      |       |    |
| benchmarking  | function | ... | function | time | 3.123 | μs |
|               |          |     |                 |      |       |    |
| benchmarking  | function | ... | function | time | 3.119 | μs |
|               |          |     |                 |      |       |    |
| tailSumGo     |          |     |                 |      |       |    |
| benchmarking  | function | ... | function | time | 4.221 | μs |
|               |          |     |                 |      |       |    |
| benchmarking  | function | ... | function | time | 4.251 | μs |
|               |          |     |                 |      |       |    |
| foldrSum      |          |     |                 |      |       |    |
| benchmarking  | function | ... | function | time | 4.281 | μs |
|               |          |     |                 |      |       |    |
| benchmarking  | function | ... | function | time | 4.209 | μs |
|               |          |     |                 |      |       |    |
| recSum        |          |     |                 |      |       |    |
| benchmarking  | function | ... | function | time | 2.531 | μs |
|               |          |     |                 |      |       |    |
| benchmarking  | function | ... | function | time | 2.536 | μs |
|               |          |     |                 |      |       |    |
| cataSum       |          |     |                 |      |       |    |
| benchmarking  | function | ... | function | time | 3.116 | μs |
|               |          |     |                 |      |       |    |
| benchmarking  | function | ... | function | time | 3.113 | μs |
|               |          |     |                 |      |       |    |
| monoSum       |          |     |                 |      |       |    |
| benchmarking  | function | ... | function | time | 2.476 | μs |
|               |          |     |                 |      |       |    |
| benchmarking  | function | ... | function | time | 2.464 | μs |
|               |          |     |                 |      |       |    |
| polySum       |          |     |                 |      |       |    |
| benchmarking  | function | ... | function | time | 2.485 | μs |
|               |          |     |                 |      |       |    |
| benchmarking  | function | ... | function | time | 2.471 | μs |
|               |          |     |                 |      |       |    |
| lambdaSum     |          |     |                 |      |       |    |
| benchmarking  | function | ... | function | time | 2.476 | μs |
|               |          |     |                 |      |       |    |
| benchmarking  | function | ... | function | time | 2.456 | μs |
|               |          |     |                 |      |       |    |
| noop          |          |     |                 |      |       |    |
| benchmarking  | function | ... | function | time | 5.542 | ns |
|               |          |     |                 |      |       |    |
| benchmarking  | function | ... | function | time | 5.527 | ns |
|               |          |     |                 |      |       |    |

| fuseSum       | 616.6 ns |      |
| fuseFoldl'Sum | 617.1 ns |      |
| fuseFoldrSum  | 1.768 μs | 4596 |
| tailSum       | 3.165 μs |      |
| tailSumGo     | 4.205 μs |      |
| foldrSum      | 4.194 μs |      |
| recSum        | 2.551 μs |      |
| cataSum       | 3.120 μs |      |
| monoSum       | 2.517 μs | 6544 |
| polySum       | 2.477 μs |      |
| lambdaSum     | 2.467 μs |      |


* ghc stats

- allocated_bytes
- gcs
- gcdetails_live_bytes
- max_live_bytes
- max_mem_in_use_bytes

#+begin_src haskell
:load app/basic.hs
m <- readGHCStats "other/ghcstats.show"
xs = [x | (Just x) <- snd (head $ Map.toList m)]
average $ mutator_cpu_ns <$> (\(x,y) -> diffRTSStats x y) <$> xs
#+end_src

#+RESULTS:
: > > "4.56e6"

#+begin_src haskell
length $ filter (/=0) $ (\x -> mutator_cpu_ns x - cpu_ns x) . (\(x,y) -> diffRTSStats x y) <$> xs
#+end_src

#+RESULTS:
: 1

#+begin_src haskell
length $ filter (/=0) $ (\x -> mutator_elapsed_ns x - elapsed_ns x) . (\(x,y) -> diffRTSStats x y) <$> xs
#+end_src

#+RESULTS:
: 1

#+begin_src haskell
take 1 $ (\(x,y) -> diffRTSStats x y) <$> xs
#+end_src

#+RESULTS:
| RTSStats | (gcs = 69 major_gcs = 5 allocated_bytes = 71248704 max_live_bytes = 24028400 max_large_objects_bytes = 32768 max_compact_bytes = 0 max_slop_bytes = 4115216 max_mem_in_use_bytes = 57671680 cumulative_live_bytes = 50755760 copied_bytes = 87690760 par_copied_bytes = 0 cumulative_par_max_copied_bytes = 0 cumulative_par_balanced_copied_bytes = 0 init_cpu_ns = 0 init_elapsed_ns = 0 mutator_cpu_ns = 7033000 mutator_elapsed_ns = 7393243 gc_cpu_ns = 52961000 gc_elapsed_ns = 67889554 cpu_ns = 59994000 elapsed_ns = 75282797 nonmoving_gc_sync_cpu_ns = 0 nonmoving_gc_sync_elapsed_ns = 0 nonmoving_gc_sync_max_elapsed_ns = 0 nonmoving_gc_cpu_ns = 0 nonmoving_gc_elapsed_ns = 0 nonmoving_gc_max_elapsed_ns = 0 gc = GCDetails (gcdetails_gen = 0 gcdetails_threads = 1 gcdetails_allocated_bytes = 1032192 gcdetails_live_bytes = 39511280 gcdetails_large_objects_bytes = 32768 gcdetails_compact_bytes = 0 gcdetails_slop_bytes = 6753040 gcdetails_mem_in_use_bytes = 57671680 gcdetails_copied_bytes = 573480 gcdetails_par_max_copied_bytes = 0 gcdetails_par_balanced_copied_bytes = 0 gcdetails_sync_elapsed_ns = 1023241209498342 gcdetails_cpu_ns = 316000 gcdetails_elapsed_ns = 319087 gcdetails_nonmoving_gc_sync_cpu_ns = 0 gcdetails_nonmoving_gc_sync_elapsed_ns = 0)) |


#+begin_src haskell
length $ filter (/=0) $ (\x -> allocated_bytes x) . (\(x,y) -> diffRTSStats x y) <$> xs
#+end_src

#+RESULTS:
: 1

#+begin_src haskell
take 1 xs
#+end_src

#+RESULTS:
| RTSStats | (gcs = 0 major_gcs = 0 allocated_bytes = 0 max_live_bytes = 0 max_large_objects_bytes = 0 max_compact_bytes = 0 max_slop_bytes = 0 max_mem_in_use_bytes = 0 cumulative_live_bytes = 0 copied_bytes = 0 par_copied_bytes = 0 cumulative_par_max_copied_bytes = 0 cumulative_par_balanced_copied_bytes = 0 init_cpu_ns = 296000 init_elapsed_ns = 3702626 mutator_cpu_ns = 252000 mutator_elapsed_ns = 414025 gc_cpu_ns = 0 gc_elapsed_ns = 0 cpu_ns = 252000 elapsed_ns = 414025 nonmoving_gc_sync_cpu_ns = 0 nonmoving_gc_sync_elapsed_ns = 0 nonmoving_gc_sync_max_elapsed_ns = 0 nonmoving_gc_cpu_ns = 0 nonmoving_gc_elapsed_ns = 0 nonmoving_gc_max_elapsed_ns = 0 gc = GCDetails (gcdetails_gen = 0 gcdetails_threads = 0 gcdetails_allocated_bytes = 0 gcdetails_live_bytes = 0 gcdetails_large_objects_bytes = 0 gcdetails_compact_bytes = 0 gcdetails_slop_bytes = 0 gcdetails_mem_in_use_bytes = 0 gcdetails_copied_bytes = 0 gcdetails_par_max_copied_bytes = 0 gcdetails_par_balanced_copied_bytes = 0 gcdetails_sync_elapsed_ns = 0 gcdetails_cpu_ns = 0 gcdetails_elapsed_ns = 0 gcdetails_nonmoving_gc_sync_cpu_ns = 0 gcdetails_nonmoving_gc_sync_elapsed_ns = 0)) | RTSStats | (gcs = 69 major_gcs = 5 allocated_bytes = 71248704 max_live_bytes = 24028400 max_large_objects_bytes = 32768 max_compact_bytes = 0 max_slop_bytes = 4115216 max_mem_in_use_bytes = 57671680 cumulative_live_bytes = 50755760 copied_bytes = 87690760 par_copied_bytes = 0 cumulative_par_max_copied_bytes = 0 cumulative_par_balanced_copied_bytes = 0 init_cpu_ns = 296000 init_elapsed_ns = 3702626 mutator_cpu_ns = 7285000 mutator_elapsed_ns = 7807268 gc_cpu_ns = 52961000 gc_elapsed_ns = 67889554 cpu_ns = 60246000 elapsed_ns = 75696822 nonmoving_gc_sync_cpu_ns = 0 nonmoving_gc_sync_elapsed_ns = 0 nonmoving_gc_sync_max_elapsed_ns = 0 nonmoving_gc_cpu_ns = 0 nonmoving_gc_elapsed_ns = 0 nonmoving_gc_max_elapsed_ns = 0 gc = GCDetails (gcdetails_gen = 0 gcdetails_threads = 1 gcdetails_allocated_bytes = 1032192 gcdetails_live_bytes = 39511280 gcdetails_large_objects_bytes = 32768 gcdetails_compact_bytes = 0 gcdetails_slop_bytes = 6753040 gcdetails_mem_in_use_bytes = 57671680 gcdetails_copied_bytes = 573480 gcdetails_par_max_copied_bytes = 0 gcdetails_par_balanced_copied_bytes = 0 gcdetails_sync_elapsed_ns = 1023241209498342 gcdetails_cpu_ns = 316000 gcdetails_elapsed_ns = 319087 gcdetails_nonmoving_gc_sync_cpu_ns = 0 gcdetails_nonmoving_gc_sync_elapsed_ns = 0)) |


#+begin_src haskell
take 1 . reverse $ xs
#+end_src

#+RESULTS:
| RTSStats | (gcs = 3 major_gcs = 1 allocated_bytes = 2727088 max_live_bytes = 1806792 max_large_objects_bytes = 32768 max_compact_bytes = 0 max_slop_bytes = 32312 max_mem_in_use_bytes = 4194304 cumulative_live_bytes = 1806792 copied_bytes = 3430792 par_copied_bytes = 0 cumulative_par_max_copied_bytes = 0 cumulative_par_balanced_copied_bytes = 0 init_cpu_ns = 325000 init_elapsed_ns = 4215545 mutator_cpu_ns = 16826000 mutator_elapsed_ns = 18373905 gc_cpu_ns = 2555000 gc_elapsed_ns = 3204377 cpu_ns = 19381000 elapsed_ns = 21578282 nonmoving_gc_sync_cpu_ns = 0 nonmoving_gc_sync_elapsed_ns = 0 nonmoving_gc_sync_max_elapsed_ns = 0 nonmoving_gc_cpu_ns = 0 nonmoving_gc_elapsed_ns = 0 nonmoving_gc_max_elapsed_ns = 0 gc = GCDetails (gcdetails_gen = 1 gcdetails_threads = 1 gcdetails_allocated_bytes = 889344 gcdetails_live_bytes = 1806792 gcdetails_large_objects_bytes = 32768 gcdetails_compact_bytes = 0 gcdetails_slop_bytes = 32312 gcdetails_mem_in_use_b bbytes = 4194304 gcdetails_copied_bytes = 1774040 gcdetails_par_max_copied_bytes = 0 gcdetails_par_balanced_copied_bytes = 0 gcdetails_sync_elapsed_ns = 1016690408670729 gcdetails_cpu_ns = 1217000 gcdetails_elapsed_ns = 1567660 gcdetails_nonmoving_gc_sync_cpu_ns = 0 gcdetails_nonmoving_gc_sync_elapsed_ns = 0)) | RTSStats | (gcs = 3 major_gcs = 1 allocated_bytes = 2727088 max_live_bytes = 1806792 max_large_objects_bytes = 32768 max_compact_bytes = 0 max_slop_bytes = 32312 max_mem_in_use_bytes = 4194304 cumulative_live_bytes = 1806792 copied_bytes = 3430792 par_copied_bytes = 0 cumulative_par_max_copied_bytes = 0 cumulative_par_balanced_copied_bytes = 0 init_cpu_ns = 325000 init_elapsed_ns = 4215545 mutator_cpu_ns = 16838000 mutator_elapsed_ns = 18387036 gc_cpu_ns = 2555000 gc_elapsed_ns = 3204377 cpu_ns = 19393000 elapsed_ns = 21591413 nonmoving_gc_sync_cpu_ns = 0 nonmoving_gc_sync_elapsed_ns = 0 nonmoving_gc_sync_max_elapsed_ns = 0 nonmoving_gc_cpu_ns = 0 nonmoving_gc_elapsed_ns = 0 nonmoving_gc_max_elapsed_ns = 0 gc = GCDetails (gcdetails_gen = 1 gcdetails_threads = 1 gcdetails_allocated_bytes = 889344 gcdetails_live_bytes = 1806792 gcdetails_large_objects_bytes = 32768 gcdetails_compact_bytes = 0 gcdetails_slop_bytes = 32312 gcdetails_mem_in_use_bytes = 4194304 gcdetails_copied_bytes = 1774040 gcdetails_par_max_copied_bytes = 0 gcdetails_par_balanced_copied_bytes = 0 gcdetails_sync_elapsed_ns = 1016690408670729 gcdetails_cpu_ns = 1217000 gcdetails_elapsed_ns = 1567660 gcdetails_nonmoving_gc_sync_cpu_ns = 0 gcdetails_nonmoving_gc_sync_elapsed_ns = 0)) |




* Resources

[[https://en.wikipedia.org/wiki/Time_Stamp_Counter][rdtsc]]


* ToDo zipping

#+begin_src haskell
-- * zipping
-- from https://doisinkidney.com/posts/2019-05-08-list-manipulation-tricks.html

-- what is the name of this type of recursion?
zipRec :: [a] -> [b] -> [(a,b)]
zipRec [] _ = []
zipRec _ [] = []
zipRec (x:xs) (y:ys) = (x,y) : zipRec xs ys

-- step 1: write as a case statement on the first argument

zipCase :: [a] -> [b] -> [(a,b)]
zipCase xs = case xs of
  [] -> const []
  (x:xs') -> \case
    [] -> []
    (y:ys) -> (x,y):zipCase xs' ys

-- step 2: rewrite the case statements as auxillary functions
zipAux :: [a] -> [b] -> [(a,b)]
zipAux xs = case xs of
  [] -> b
  (x:xs') -> f x xs'
  where
    b _ = []
    f x xs' = \case
      [] -> []
      (y:ys) -> (x,y):zipAux xs' ys

-- step 3: refactor the recursive call to the first case expression
zipRef :: [a] -> [b] -> [(a,b)]
zipRef xs = case xs of
  [] -> b
  (x:xs') -> f x (zipRef xs')
  where
    b _ = []
    f x xs' = \case
      [] -> []
      (y:ys) -> (x,y): xs' ys

-- step 4 pass the auxillary functions to foldr
-- zipR :: [a] -> [b] -> [(a,b)]
zipR :: [a] -> [b] -> [(a, b)]
zipR = foldr f b
  where
    b _ = []
    f x xs = \case
      [] -> []
      (y:ys) -> (x,y): xs ys

zipR' :: [a] -> [b] -> [(a, b)]
zipR' = foldr f (const [])
  where
    f x xs ys = case ys of
      [] -> []
      (y:ys') -> (x,y): xs ys'

-- from https://doisinkidney.com/posts/2020-08-22-some-more-list-algorithms.html
newtype Zip a b =
  Zip { runZip :: a -> (Zip a b -> b) -> b }

zipZ :: [a] -> [b] -> [(a,b)]
zipZ xs ys = foldr xf (const []) xs (Zip (foldr yf yb ys))
  where
    xf x xk yk = runZip yk x xk

    yf y yk x xk = (x,y) : xk (Zip yk)
    yb _ _ = []

newtype a -&> b = Hyp { invoke :: (b -&> a) -> b }

{-
FIXME:

zipHyp :: forall a b. [a] -> [b] -> [(a,b)]
zipHyp xs ys = invoke xz yz
  where
    xz :: (a -> [(a,b)]) -&> [(a,b)]
    xz = foldr f b xs
      where
        f x xk = Hyp (\yk -> invoke yk xk x)
        b = Hyp (\_ -> [])

    yz :: [(a,b)] -&> (a -> [(a,b)])
    yz = foldr f b ys
      where
        f y yk = Hyp (\xk x -> (x,y) : invoke xk yk)
        b = Hyp (\_ _ -> [])

-}

-- a -&> a ~ Fix (Cont a)
newtype HypP p a b = HypP { invokeP :: p (HypP p b a) b }
newtype HypM m a b = HypM { invokeM :: m ((HypM m a b -> a) -> b) }
#+end_src
